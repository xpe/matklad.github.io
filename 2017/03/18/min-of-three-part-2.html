<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Min of Three Part 2</title>
  <meta name="description"
    content="">
  <link rel="canonical" href="https://matklad.github.io//2017/03/18/min-of-three-part-2.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Min of Three Part 2</h1>
  <div class="post-meta sect1">Mar 18, 2017</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is the continuation of the <a href="/2017/03/12/min-of-three.html">previous post</a> about optimizing 2D grid
based dynamic programming algorithm for <a href="https://en.wikipedia.org/wiki/Superscalar_processor">CPU level parallelism</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="in-the-previous-episode"><a class="anchor" href="#in-the-previous-episode"></a>In The Previous Episode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the code we are trying to make faster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">dtw</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f64</span><span class="p">],</span> <span class="n">ys</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f64</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="c">// assume equal lengths for simplicity</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">xs</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">ys</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">xs</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">prev</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mf">0f64</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">curr</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">curr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">ix</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">curr</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">prev</span><span class="p">);</span>
        <span class="n">curr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">iy</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">d11</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">d01</span> <span class="o">=</span> <span class="n">curr</span><span class="p">[</span><span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">d10</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">iy</span><span class="p">];</span>

            <span class="c">// Find the minimum of d11, d01, d10</span>
            <span class="c">// by enumerating all the cases.</span>
            <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="k">if</span> <span class="n">d11</span> <span class="o">&lt;</span> <span class="n">d01</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">d11</span> <span class="o">&lt;</span> <span class="n">d10</span> <span class="p">{</span> <span class="n">d11</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">d10</span> <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">d01</span> <span class="o">&lt;</span> <span class="n">d10</span> <span class="p">{</span> <span class="n">d01</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">d10</span> <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">cost</span> <span class="o">=</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ys</span><span class="p">[</span><span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
            <span class="p">};</span>

            <span class="n">curr</span><span class="p">[</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">curr</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=3d42c67904441279c4cbb1708fb35a06&amp;version=stable">Code on Rust playground</a> (293 ms)</p>
</div>
<div class="paragraph">
<p>It calculates <a href="https://en.wikipedia.org/wiki/Dynamic_time_warping">dynamic time warping</a> distance between two <code>double</code>
vectors using an update rule which is structured like this:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/assets/min3_table.png" alt="Dynamic programming 2D table">
</div>
</div>
<div class="paragraph">
<p>This code takes 293 milliseconds to run on a particular input
data. The speedup from 435 milliseconds stated in the previous post is
due to the Moor&#8217;s law: I&#8217;ve upgraded the CPU :)</p>
</div>
<div class="paragraph">
<p>We can bring run time down by tweaking how we calculate the minimum of
three elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">min2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="p">{</span> <span class="n">x</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">y</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">dtw</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f64</span><span class="p">],</span> <span class="n">ys</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f64</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="c">// ...</span>
            <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">min2</span><span class="p">(</span><span class="nf">min2</span><span class="p">(</span><span class="n">d11</span><span class="p">,</span> <span class="n">d10</span><span class="p">),</span> <span class="n">d01</span><span class="p">);</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=caf7609db82341fb7ccf13033738232e&amp;version=stable">Code on Rust playground</a> (210 ms)</p>
</div>
<div class="paragraph">
<p>This version takes only 210 milliseconds, presumably because the
minimum of two elements in the previous row can be calculated without
waiting for the preceding element in the current row to be computed.</p>
</div>
<div class="paragraph">
<p>The assembly for the main loop looks like this (AT&amp;T syntax,
destination register on the right)</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   18.32    vmovsd -0x8(%rax,%rsi,8),%xmm1
    0.00    vminsd (%rax,%rsi,8),%xmm1,%xmm1
    6.72    vminsd %xmm0,%xmm1,%xmm0
    4.64    vmovsd -0x8(%r12,%r10,8),%xmm1
    0.00    vsubsd -0x8(%r13,%rsi,8),%xmm1,%xmm1
    7.69    vmulsd %xmm1,%xmm1,%xmm1
   36.14    vaddsd %xmm1,%xmm0,%xmm0
   14.16    vmovsd %xmm0,(%rdi,%rsi,8)</pre>
</div>
</div>
<div class="paragraph">
<p>Check the <a href="/2017/03/12/min-of-three.html">previous post</a> for more details!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-parallel-plan"><a class="anchor" href="#the-parallel-plan"></a>The parallel plan</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Can we loosen dependencies between cells even more to benefit from instruction
level parallelism? What if instead of filling the table row by row, we do it
diagonals?</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="/assets/min3_diag_color.png" alt="Diagonal update">
</div>
</div>
<div class="paragraph">
<p>We&#8217;d need to remember <strong>two</strong> previous diagonals instead of one previous
row, but all the cells on the next diagonal would be independent! In
theory, compiler should be able to use <a href="https://en.wikipedia.org/wiki/SIMD#Hardware">SIMD instructions</a> to make the
computation truly parallel.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation-plan"><a class="anchor" href="#implementation-plan"></a>Implementation Plan</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Coding up this diagonal traversal is a bit tricky, because you need to
map linear vector indices to diagonal indices.</p>
</div>
<div class="paragraph">
<p>The original indexing worked like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>        iy
       ----&gt;
    | . . . .
 ix | . . . .
    | . . . .
    V . . . .</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ix</code> and <code>iy</code> are indices in the input vectors.</p>
</li>
<li>
<p>The outer loop is over <code>ix</code>.</p>
</li>
<li>
<p>On each iteration, we remember two rows (<code>curr</code> and <code>prev</code> in the
code).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For our grand plan, we need to fit a rhombus peg in a square hole:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   id
  ----&gt;
 . . . .        |
   . . . .      | ix
     . . . .    |
       . . . .  V</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> is the index of the diagonal. There are twice as much diagonals
as rows.</p>
</li>
<li>
<p>The outer loop is over <code>id</code>.</p>
</li>
<li>
<p>On each iteration we remember three columns (<code>d1</code>, <code>d2</code> <code>d3</code> in the
code).</p>
</li>
<li>
<p>There is a phase transition once we&#8217;ve crossed the main diagonal.</p>
</li>
<li>
<p>We can derive <code>iy</code> from the fact that <code>ix + iy = id</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="code"><a class="anchor" href="#code"></a>Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The actual code looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">dtw</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f64</span><span class="p">],</span> <span class="n">ys</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f64</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">f64</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">xs</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">ys</span><span class="nf">.len</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">xs</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">d1</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mf">0f64</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">d2</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mf">0f64</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">d3</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mf">0f64</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">d2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">id</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">d1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">d2</span><span class="p">);</span>
        <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">d2</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">d3</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">ix_range</span> <span class="o">=</span> <span class="k">if</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">d3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>
            <span class="n">d3</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>
            <span class="mi">1</span><span class="o">..</span><span class="n">id</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">n</span><span class="o">..</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="k">for</span> <span class="n">ix</span> <span class="n">in</span> <span class="n">ix_range</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">id</span> <span class="o">-</span> <span class="n">ix</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">min2</span><span class="p">(</span><span class="nf">min2</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d2</span><span class="p">[</span><span class="n">ix</span><span class="p">]),</span> <span class="n">d1</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
            <span class="k">let</span> <span class="n">cost</span> <span class="o">=</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ys</span><span class="p">[</span><span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
            <span class="p">};</span>
            <span class="n">d3</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="n">d3</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=4522cb9d4d0e95e9daa4b1f1d6a563b0&amp;version=stable">Code on Rust playground</a> (185 ms)</p>
</div>
<div class="paragraph">
<p>It take 185 milliseconds to run. The assembly for the main loop is
quite interesting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    1.67    cmp    %rax,%rdx
    0.00    jbe    6d95
    1.95    lea    0x1(%rax),%rbx
    8.09    cmp    %rbx,%rdx
    0.98    jbe    6da4
    1.12    cmp    %rax,%r8
    0.00    jbe    6db3
    3.49    cmp    %r12,%rax
    0.00    jae    6de9
    9.07    cmp    %r12,%rcx
    0.00    jae    6dc5
    0.56    cmp    %rbx,%r9
    0.00    jbe    6dd7
    2.23    vmovsd (%r15,%rax,8),%xmm0
   11.72    vminsd 0x8(%r15,%rax,8),%xmm0,%xmm0
    2.09    vminsd (%r11,%rax,8),%xmm0,%xmm0
    2.51    vmovsd (%r14,%rax,8),%xmm1
    7.95    mov    -0x88(%rbp),%rdi
    3.07    vsubsd (%rdi,%rcx,8),%xmm1,%xmm1
    3.91    vmulsd %xmm1,%xmm1,%xmm1
   15.90    vaddsd %xmm1,%xmm0,%xmm0
    8.37    vmovsd %xmm0,0x8(%r13,%rax,8)</pre>
</div>
</div>
<div class="paragraph">
<p>First of all, we don&#8217;t see any vectorized instructions, the code does
roughly the same operations as the in previous version. Also, there is
a whole bunch of extra branching instructions on the top. These are
bounds checks which were not eliminated this time. And this is great:
if I add all off-by one errors I&#8217;ve made implementing diagonal
indexing, I would get an integer overflow! Nevertheless, we&#8217;ve got
some speedup.</p>
</div>
<div class="paragraph">
<p>Can we go further and add get SIMD instructions here? At the moment,
Rust does not have a stable way to explicitly emit SIMD
(<a href="https://internals.rust-lang.org/t/getting-explicit-simd-on-stable-rust/4380">it&#8217;s going to change some day</a>) (UPDATE: we have <a href="https://doc.rust-lang.org/core/arch/index.html">SIMD on stable</a> now!), so the only choice we
have is to tweak the source code until LLVM sees an opportunity for
vectorization.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="simd"><a class="anchor" href="#simd"></a>SIMD</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although bounds checks themselves don&#8217;t slow down the code that much,
they can prevent LLVM from vectorizing. So let&#8217;s dip our toes into
<code>unsafe</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="k">unsafe</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">min2</span><span class="p">(</span>
        <span class="nf">min2</span><span class="p">(</span><span class="o">*</span><span class="n">d2</span><span class="nf">.get_unchecked</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">d2</span><span class="nf">.get_unchecked</span><span class="p">(</span><span class="n">ix</span><span class="p">)),</span>
        <span class="o">*</span><span class="n">d1</span><span class="nf">.get_unchecked</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">cost</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span>
            <span class="n">xs</span><span class="nf">.get_unchecked</span><span class="p">(</span><span class="n">ix</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ys</span><span class="nf">.get_unchecked</span><span class="p">(</span><span class="n">iy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
    <span class="p">};</span>
    <span class="o">*</span><span class="n">d3</span><span class="nf">.get_unchecked_mut</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=a7d7e447794eda6fef7b08a28c2c79da&amp;version=stable">Code on Rust playground</a> (52 ms)</p>
</div>
<div class="paragraph">
<p>The  code is  as  fast as  it  is  ugly: it  finishes  in whooping  52
milliseconds! And of course we see SIMD in the assembly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    5.74    vmovupd -0x8(%r8,%rcx,8),%ymm0
    1.44    vminpd (%r8,%rcx,8),%ymm0,%ymm0
    7.66    vminpd -0x8(%r11,%rcx,8),%ymm0,%ymm0
    5.26    vmovupd -0x8(%rbx,%rcx,8),%ymm1
    7.66    vpermpd $0x1b,0x20(%r12),%ymm2
    5.26    vsubpd %ymm2,%ymm1,%ymm1
    7.66    vmulpd %ymm1,%ymm1,%ymm1
    8.61    vaddpd %ymm1,%ymm0,%ymm0
    2.39    vmovupd %ymm0,(%rdx,%rcx,8)
    2.39    vmovupd 0x18(%r8,%rcx,8),%ymm0
    5.74    vminpd 0x20(%r8,%rcx,8),%ymm0,%ymm0
    9.09    vminpd 0x18(%r11,%rcx,8),%ymm0,%ymm0
    0.96    vmovupd 0x18(%rbx,%rcx,8),%ymm1
    4.78    vpermpd $0x1b,(%r12),%ymm2
    3.83    vsubpd %ymm2,%ymm1,%ymm1
    3.83    vmulpd %ymm1,%ymm1,%ymm1
   10.53    vaddpd %ymm1,%ymm0,%ymm0
    4.78    vmovupd %ymm0,0x20(%rdx,%rcx,8)</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="safe-simd"><a class="anchor" href="#safe-simd"></a>Safe SIMD</h2>
<div class="sectionbody">
<div class="paragraph">
<p>How can we get the same results with safe Rust? One possible way is to
use iterators, but in this case the resulting code would be rather
ugly, because you&#8217;ll need a lot of nested <code>.zip</code>'s. So let&#8217;s try a
simple trick of hoisting the bounds checks of the loop. The idea is to
transform this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>for i in 0..n {
    assert i &lt; xs.len();
    xs.get_unchecked(i);
}</pre>
</div>
</div>
<div class="paragraph">
<p>into this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>assert xs.len() &lt; n;
for i in 0..n {
    xs.get_unchecked(i);
}</pre>
</div>
</div>
<div class="paragraph">
<p>In Rust, this is possible by explicitly slicing the buffer before the loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">ix_range</span> <span class="o">=</span> <span class="k">if</span> <span class="n">id</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
    <span class="n">d3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>
    <span class="n">d3</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">::</span><span class="nn">std</span><span class="p">::</span><span class="nn">f64</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span>
    <span class="mi">1</span><span class="o">..</span><span class="n">id</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">id</span> <span class="o">-</span> <span class="n">n</span><span class="o">..</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">let</span> <span class="n">ix_range_1</span> <span class="o">=</span> <span class="n">ix_range</span><span class="py">.start</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">ix_range</span><span class="py">.end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">let</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">ix_range</span><span class="py">.end</span> <span class="o">-</span> <span class="n">ix_range</span><span class="py">.start</span><span class="p">;</span>

<span class="k">let</span> <span class="n">d1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">[</span><span class="n">ix_range_1</span><span class="nf">.clone</span><span class="p">()];</span>
<span class="k">let</span> <span class="n">d2_0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2</span><span class="p">[</span><span class="n">ix_range</span><span class="nf">.clone</span><span class="p">()];</span>
<span class="k">let</span> <span class="n">d2_1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2</span><span class="p">[</span><span class="n">ix_range_1</span><span class="nf">.clone</span><span class="p">()];</span>
<span class="k">let</span> <span class="n">d3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">d3</span><span class="p">[</span><span class="n">ix_range</span><span class="nf">.clone</span><span class="p">()];</span>
<span class="k">let</span> <span class="n">xs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xs</span><span class="p">[</span><span class="n">ix_range_1</span><span class="nf">.clone</span><span class="p">()];</span>
<span class="k">let</span> <span class="n">ys</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ys</span><span class="p">[</span><span class="n">id</span> <span class="o">-</span> <span class="n">ix_range</span><span class="py">.end</span><span class="o">..</span><span class="n">id</span> <span class="o">-</span> <span class="n">ix_range</span><span class="py">.start</span><span class="p">];</span>

<span class="c">// All the buffers we access inside the loop</span>
<span class="c">// will have the same length</span>
<span class="k">assert</span><span class="o">!</span><span class="p">(</span>
    <span class="n">d1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">d2_0</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">d2_1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">dn</span>
    <span class="o">&amp;&amp;</span> <span class="n">d3</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">xs</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">dn</span> <span class="o">&amp;&amp;</span> <span class="n">ys</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">dn</span>
<span class="p">);</span>

<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">dn</span> <span class="p">{</span> <span class="c">// so hopefully LLVM can eliminate bounds checks.</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">min2</span><span class="p">(</span><span class="nf">min2</span><span class="p">(</span><span class="n">d2_0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">d2_1</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">d1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">let</span> <span class="n">cost</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ys</span><span class="p">[</span><span class="n">ys</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
    <span class="p">};</span>
    <span class="n">d3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=65a707923aa0d49aa06e84c509c83bed&amp;version=stable">Code on Rust playground</a> (107 ms)</p>
</div>
<div class="paragraph">
<p>This is definitely an improvement over the best safe version, but is
still twice as slow as the unsafe variant. Looks like some bounds
checks are still there! It is possible to find them by selectively
using <code>unsafe</code> to replace some indexing operations.</p>
</div>
<div class="paragraph">
<p>And it turns out that only <code>ys</code> is still checked!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">ys</span><span class="nf">.get_unchecked</span><span class="p">(</span><span class="n">ys</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=d735daf2993acd1286d399c813546c71&amp;version=stable">Code on Rust playground</a> (52 ms)</p>
</div>
<div class="paragraph">
<p>If we use <code>unsafe</code> only for <code>ys</code>, we regain all the performance.</p>
</div>
<div class="paragraph">
<p>LLVM is having trouble iterating <code>ys</code> in reverse, but the fix is easy:
just reverse it once at the beginning of the function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">ys_rev</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">f64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ys</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://play.rust-lang.org/?gist=6f6bcf941df819d10f8fa688f86765ad&amp;version=stable">Code on Rust playground</a> (50 ms)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusions"><a class="anchor" href="#conclusions"></a>Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ve gone from almost 300 milliseconds to only 50 in safe Rust. That
is quite impressive! However, the resulting code is rather brittle and
even small changes can prevent vectorization from triggering.</p>
</div>
<div class="paragraph">
<p>It&#8217;s also important to understand that to allow for SIMD, we had to
change the underlying algorithm. This is not something even a very
smart compiler could do!</p>
</div>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2017-03-18-min-of-three-part-2.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
