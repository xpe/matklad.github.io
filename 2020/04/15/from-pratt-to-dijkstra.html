<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>From Pratt to Dijkstra</title>
  <meta name="description"
    content="">
  <link rel="canonical" href="https://matklad.github.io//2020/04/15/from-pratt-to-dijkstra.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>From Pratt to Dijkstra</h1>
  <div class="post-meta sect1">Apr 15, 2020</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is a sequel to the <a href="/2020/04/13/simple-but-powerful-pratt-parsing.html">previous post</a> about Pratt parsing.
Here, we&#8217;ll study the relationship between top-down operator precedence (Pratt parsing) and the more famous shunting yard algorithm.
Spoiler: they are the same algorithm, the difference is implementation style with recursion (Pratt) or a manual stack (Dijkstra).</p>
</div>
<div class="paragraph">
<p>Unlike the previous educational post, this one is going to be an excruciatingly boring pile of technicalities&#8201;&#8212;&#8201;we&#8217;ll just slowly and mechanically refactor our way to victory.
Specifically,</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We start with refactoring Pratt parser to minimize control flow variations.</p>
</li>
<li>
<p>Then, having arrived at the code with only one <code>return</code> and only one recursive call, we replace recursion with an explicit stack.</p>
</li>
<li>
<p>Finally, we streamline control in the iterative version.</p>
</li>
<li>
<p>At this point, we have a bona fide shunting yard algorithm.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To further reveal the connection, we further verify that the original recursive and the iterative formulation produce syntax nodes in the same order.</p>
</div>
<div class="paragraph">
<p>Really, the most exciting bit about this post is the conclusion, and you already know it :)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-point"><a class="anchor" href="#starting-point"></a>Starting Point</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Last time, we&#8217;ve ended up with the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
</pre></td><td class="code"><pre><span class="k">enum</span> <span class="n">S</span> <span class="p">{</span>
    <span class="nf">Atom</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}"</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">s</span> <span class="n">in</span> <span class="n">rest</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">" {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">?</span>
                <span class="p">}</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">")"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="nf">Atom</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="nf">Op</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="n">Eof</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="n">tokens</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Lexer</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">input</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="o">!</span><span class="n">it</span><span class="nf">.is_ascii_whitespace</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
                <span class="sc">'0'</span><span class="o">..=</span><span class="sc">'9'</span>
                <span class="p">|</span> <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">tokens</span><span class="nf">.reverse</span><span class="p">();</span>
        <span class="n">Lexer</span> <span class="p">{</span> <span class="n">tokens</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Token</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tokens</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">Token</span><span class="p">::</span><span class="n">Eof</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Token</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tokens</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">Token</span><span class="p">::</span><span class="n">Eof</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lexer</span> <span class="o">=</span> <span class="nn">Lexer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nf">expr_bp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">S</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">),</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="n">lhs</span>
        <span class="p">}</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">((),</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span> <span class="nf">prefix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">rhs</span><span class="p">])</span>
        <span class="p">}</span>
        <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">Token</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">op</span><span class="p">,</span>
            <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="p">()))</span> <span class="o">=</span> <span class="nf">postfix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="n">lhs</span> <span class="o">=</span> <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="sc">'['</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">']'</span><span class="p">));</span>
                <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">])</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">lhs</span><span class="p">])</span>
            <span class="p">};</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="o">=</span> <span class="nf">infix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="n">lhs</span> <span class="o">=</span> <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="sc">'?'</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">mhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">':'</span><span class="p">));</span>
                <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
                <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">mhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">])</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
                <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">])</span>
            <span class="p">};</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lhs</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">prefix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">((),</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">((),</span> <span class="mi">9</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad op: {:?}"</span><span class="p">,</span> <span class="n">op</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">postfix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="p">())</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="p">()),</span>
        <span class="sc">'['</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="p">()),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">infix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'?'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>First, to not completely drown in minutia, we&#8217;ll simplify it by removing support for indexing operator <code>[]</code> and ternary operator <code>?:</code>.
We will keep parenthesis, left and right associative operators, and the unary minus (which is somewhat tricky to handle in shunting yard).
So this is our starting point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">S</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">),</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="n">lhs</span>
        <span class="p">}</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">((),</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span> <span class="nf">prefix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">rhs</span><span class="p">])</span>
        <span class="p">}</span>
        <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">Token</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">op</span><span class="p">,</span>
            <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="p">()))</span> <span class="o">=</span> <span class="nf">postfix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="n">lhs</span> <span class="o">=</span> <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">lhs</span><span class="p">]);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="o">=</span> <span class="nf">infix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">]);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lhs</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>What I like about this code is how up-front it is about all special cases and control flow.
This is a &#8220;shameless green&#8221; code!
However, it is clear that we have a bunch of duplication between prefix, infix and postfix operators.
Our first step would be to simplify the control flow to its core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="minimization"><a class="anchor" href="#minimization"></a>Minimization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, let&#8217;s merge postfix and infix cases, as they are almost the same.
The idea is to change priorities for <code>!</code> from <code>(11, ())</code> to <code>(11, 100)</code>, where <code>100</code> is a special, very strong priority, which means that the right hand side of a "binary" operator is empty.
We&#8217;ll handle this in a pretty crude way right now, but all the hacks would go away once we refactor the rest.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">min_bp</span> <span class="o">==</span> <span class="mi">100</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">S</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">),</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="n">lhs</span>
        <span class="p">}</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">((),</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span> <span class="nf">prefix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">rhs</span><span class="p">])</span>
        <span class="p">}</span>
        <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">Token</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">op</span><span class="p">,</span>
            <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="o">=</span> <span class="nf">infix_binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="n">args</span><span class="nf">.push</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">Some</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Yup, we just check for hard-coded <code>100</code> constant and use a bunch of unwraps all over the place.
But the code is already smaller.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s apply the same treatment for prefix operators.
We&#8217;ll need to move their handing into the loop, and we also need to make <code>lhs</code> optional, which is now not a big deal, as the function as a whole returns an <code>Option</code>.
On a happier note, this will allow us to remove the <code>if 100</code> wart.
What&#8217;s more problematic is handing priorities: minus has different binding powers depending on whether it is in an infix or a prefix position.
We solve this problem by just adding an <code>prefix: bool</code> argument to the <code>binding_power</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Atom</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">Token</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
            <span class="nn">Token</span><span class="p">::</span><span class="nf">Op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">op</span><span class="p">,</span>
            <span class="n">t</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"bad token: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="o">=</span>
            <span class="nf">binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">lhs</span><span class="nf">.is_none</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lhs</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Keen readers might have noticed that we use <code>99</code> and not <code>100</code> here for "no operand" case.
This is not important yet, but will be during the next step.</p>
</div>
<div class="paragraph">
<p>We&#8217;ve unified prefix, infix and postfix operators.
The next logical step is to treat atoms as nullary operators!
That is, we&#8217;ll parse <code>92</code> into <code>(92)</code> S-expression, with <code>None</code> for both <code>lhs</code> and <code>rhs</code>.
We get this by using <code>(99, 100)</code> binding power.
At this stage, we can get rid of distinction between atom tokens and operator tokens, and make the lexer return underlying <code>char</code>'s directly.
We&#8217;ll also get rid of <code>S::Atom</code>, which gives us this somewhat large change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
</pre></td><td class="code"><pre><span class="k">enum</span> <span class="n">S</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}"</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="n">in</span> <span class="n">rest</span> <span class="p">{</span>
                        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">" {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">?</span>
                    <span class="p">}</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">")"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="n">tokens</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Lexer</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">input</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="o">!</span><span class="n">it</span><span class="nf">.is_ascii_whitespace</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">tokens</span><span class="nf">.reverse</span><span class="p">();</span>
        <span class="n">Lexer</span> <span class="p">{</span> <span class="n">tokens</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tokens</span><span class="nf">.pop</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tokens</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lexer</span> <span class="o">=</span> <span class="nn">Lexer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nf">expr_bp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">token</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="o">=</span>
            <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">lhs</span><span class="nf">.is_none</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lhs</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'0'</span><span class="o">..=</span><span class="sc">'9'</span> <span class="p">|</span> <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the stage where it becomes important that "fake" binding power of unary <code>-</code> is <code>99</code>.
After parsing first constant in <code>1 - 2</code> the <code>r_bp</code> is <code>100</code>, and we need to avoid eating the following minus.</p>
</div>
<div class="paragraph">
<p>The only thing left outside the main loop are parenthesis.
We can deal with them using <code>(99, 0)</code> priority&#8201;&#8212;&#8201;after <code>(</code> we enter a new context where all operators are allowed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">token</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="o">=</span>
            <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">lhs</span><span class="nf">.is_none</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">l_bp</span> <span class="o">&lt;</span> <span class="n">min_bp</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">'('</span> <span class="p">{</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
            <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lhs</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'0'</span><span class="o">..=</span><span class="sc">'9'</span> <span class="p">|</span> <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'('</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, after some control flow cleanup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">token</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">lhs</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">r_bp</span> <span class="o">=</span> <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">))</span> <span class="k">if</span> <span class="n">min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span> <span class="n">r_bp</span><span class="p">,</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">lhs</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">'('</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
        <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is still recognizably a Pratt parse, with its characteristic shape</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">parse_expr</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="nf">parse_expr</span><span class="p">()</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>What we&#8217;ll do next is mechanical replacement of recursion with a manual stack.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="from-recursion-to-stack"><a class="anchor" href="#from-recursion-to-stack"></a>From Recursion to Stack</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a general transformation and (I think) it can be done mechanically.
The interesting bits during transformation are recursive calls themselves and returns.
The underlying goal of the preceding refactorings was to reduce the number of recursive invocations to one.
We still have two <code>return</code> statements there, so let&#8217;s condense that to just one as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span>
            <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)))</span> <span class="k">if</span> <span class="n">min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">lhs</span><span class="p">,</span>
            <span class="p">};</span>

        <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">'('</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
        <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">binding_power</span><span class="p">(</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">))</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'0'</span><span class="o">..=</span><span class="sc">'9'</span> <span class="p">|</span> <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'('</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we should reify locals which are live across the recursive call into a data structure.
If there were more than one recursive call, we&#8217;d have to reify control-flow as enum as well, but we&#8217;ve prudently removed all but one recursive invocation.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s start with introducing a <code>Frame</code> struct, without actually adding a stack just yet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Frame</span> <span class="p">{</span>
    <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="n">lhs</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">token</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
        <span class="n">min_bp</span><span class="p">,</span>
        <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span>
            <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">top</span><span class="py">.lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)))</span> <span class="k">if</span> <span class="n">top</span><span class="py">.min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">top</span><span class="py">.lhs</span><span class="p">,</span>
            <span class="p">};</span>
        <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

        <span class="n">top</span><span class="py">.token</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">'('</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
            <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">top</span><span class="py">.lhs</span><span class="p">);</span>
        <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
        <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And now, let&#8217;s add a <code>stack: Vec&lt;Frame&gt;</code>.
This is the point where the magic happens.
We&#8217;ll still keep the <code>top</code> local variable: representing a stack as <code>(T, Vec&lt;T&gt;)</code> and not as just <code>Vec&lt;T&gt;</code> gives us compile-time guarantee of non-emptiness.
We replace the <code>expr_bp(lexer, r_bp)</code> recursive call with pushing to the stack.
All operations after the call are moved after <code>return</code>.
<code>return</code> itself is replaced with popping off the stack.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
        <span class="n">min_bp</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span>
            <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">top</span><span class="py">.lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)))</span> <span class="k">if</span> <span class="n">top</span><span class="py">.min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="k">match</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">,</span>
                    <span class="p">};</span>

                    <span class="k">if</span> <span class="n">res</span><span class="py">.token</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
                        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lexer</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">')'</span><span class="p">));</span>
                        <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">;</span>
                        <span class="k">continue</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">top</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">res</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">res</span><span class="py">.token</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">args</span><span class="p">));</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">};</span>
        <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>

        <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
            <span class="n">min_bp</span><span class="p">:</span> <span class="n">r_bp</span><span class="p">,</span>
            <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">),</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Tada! No recursion anymore, and still passes the tests!
Let&#8217;s cleanup this further though.
First, let&#8217;s treat <code>)</code> more like a usual operator.
The correct binding powers here are the opposite of <code>(</code>: <code>(0, 100)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
        <span class="n">min_bp</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.peek</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span>
            <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">top</span><span class="py">.lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)))</span> <span class="k">if</span> <span class="n">top</span><span class="py">.min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="k">match</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">,</span>
                    <span class="p">};</span>

                    <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">top</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">res</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">res</span><span class="py">.token</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">args</span><span class="p">));</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">};</span>
        <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">')'</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">top</span><span class="py">.token</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">'('</span><span class="p">));</span>
            <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
            <span class="n">min_bp</span><span class="p">:</span> <span class="n">r_bp</span><span class="p">,</span>
            <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">),</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">binding_power</span><span class="p">(</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">))</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'0'</span><span class="o">..=</span><span class="sc">'9'</span> <span class="p">|</span> <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'('</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">')'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s note that <code>continue</code> inside the <code>match</code> is somewhat wasteful&#8201;&#8212;&#8201;when we hit it, we&#8217;ll re-<code>peek</code> the same token again.
So let&#8217;s repeat just the match until we know we can make progress.
This also allows replacing <code>peek() / next()</code> pair with just <code>next()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
        <span class="n">min_bp</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span> <span class="k">loop</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">top</span><span class="py">.lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)))</span> <span class="k">if</span> <span class="n">top</span><span class="py">.min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="k">match</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">,</span>
                    <span class="p">};</span>

                    <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">top</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">res</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">res</span><span class="py">.token</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">args</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">};</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">')'</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">top</span><span class="py">.token</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">'('</span><span class="p">));</span>
            <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
            <span class="n">min_bp</span><span class="p">:</span> <span class="n">r_bp</span><span class="p">,</span>
            <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">),</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And guess what? This is the shunting yard algorithm, with <em>its</em> characteristic shape of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">loop</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="nf">next_token</span><span class="p">();</span>
    <span class="k">while</span> <span class="n">stack</span><span class="py">.top.priority</span> <span class="o">&gt;</span> <span class="n">token</span><span class="py">.priority</span> <span class="p">{</span>
        <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To drive the point home, let&#8217;s print the tokens we pop off the stack, to verify that we get reverse Polish notation without any kind of additional tree rearrangement, just like in the original algorithm description:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">fmt</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">BufRead</span><span class="p">};</span>

<span class="k">enum</span> <span class="n">S</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({}"</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="n">in</span> <span class="n">rest</span> <span class="p">{</span>
                        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">" {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">?</span>
                    <span class="p">}</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">")"</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="n">tokens</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Lexer</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">input</span>
            <span class="nf">.chars</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="o">!</span><span class="n">it</span><span class="nf">.is_ascii_whitespace</span><span class="p">())</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">tokens</span><span class="nf">.reverse</span><span class="p">();</span>
        <span class="n">Lexer</span> <span class="p">{</span> <span class="n">tokens</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tokens</span><span class="nf">.pop</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">S</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lexer</span> <span class="o">=</span> <span class="nn">Lexer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">lexer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="n">res</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Frame</span> <span class="p">{</span>
    <span class="n">min_bp</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="n">lhs</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">token</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">expr_bp</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
        <span class="n">min_bp</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.next</span><span class="p">();</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span> <span class="o">=</span> <span class="k">loop</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nf">binding_power</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">top</span><span class="py">.lhs</span><span class="nf">.is_none</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">l_bp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)))</span> <span class="k">if</span> <span class="n">top</span><span class="py">.min_bp</span> <span class="o">&lt;=</span> <span class="n">l_bp</span> <span class="k">=&gt;</span><span class="p">{</span>
                    <span class="k">break</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="k">match</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="nd">eprintln!</span><span class="p">();</span>
                            <span class="k">return</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">};</span>

                    <span class="k">let</span> <span class="k">mut</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">top</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="n">args</span><span class="nf">.extend</span><span class="p">(</span><span class="n">res</span><span class="py">.lhs</span><span class="p">);</span>
                    <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="n">res</span><span class="py">.token</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">eprint!</span><span class="p">(</span><span class="s">"{} "</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
                    <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">S</span><span class="p">::</span><span class="nf">Cons</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">args</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">};</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="sc">')'</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">top</span><span class="py">.token</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="sc">'('</span><span class="p">));</span>
            <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">top</span><span class="py">.lhs</span> <span class="o">=</span> <span class="n">res</span><span class="py">.lhs</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">Frame</span> <span class="p">{</span>
            <span class="n">min_bp</span><span class="p">:</span> <span class="n">r_bp</span><span class="p">,</span>
            <span class="n">lhs</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">),</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">binding_power</span><span class="p">(</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">char</span><span class="p">,</span> <span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">))</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">match</span> <span class="n">op</span> <span class="p">{</span>
        <span class="sc">'0'</span><span class="o">..=</span><span class="sc">'9'</span> <span class="p">|</span> <span class="sc">'a'</span><span class="o">..=</span><span class="sc">'z'</span> <span class="p">|</span> <span class="sc">'A'</span><span class="o">..=</span><span class="sc">'Z'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'('</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="sc">')'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'='</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
        <span class="sc">'+'</span> <span class="p">|</span> <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
        <span class="sc">'*'</span> <span class="p">|</span> <span class="sc">'/'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="sc">'!'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
        <span class="sc">'.'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">Some</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">tests</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"1"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"1"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"1 + 2 * 3"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(+ 1 (* 2 3))"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"a + b * c * d + e"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(+ (+ a (* (* b c) d)) e)"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"f . g . h"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(. f (. g h))"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">" 1 + 2 + f . g . h * 3 * 4"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))"</span>
    <span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"--1 * 2"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(* (- (- 1)) 2)"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"--f . g"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(- (- (. f g)))"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"-9!"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(- (! 9))"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"f . g !"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(! (. f g))"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"(((0)))"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"0"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"(1 + 2) * 3"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(* (+ 1 2) 3)"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nf">expr</span><span class="p">(</span><span class="s">"1 + (2 * 3)"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"(+ 1 (* 2 3))"</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre>1
1
1

1 + 2 * 3
1 2 3 * +
(+ 1 (* 2 3))

a + b * c * d + e
a b c * d * + e +
(+ (+ a (* (* b c) d)) e)

f . g . h
f g h . .
(. f (. g h))

 1 + 2 + f . g . h * 3 * 4
1 2 + f g h . . 3 * 4 * +
(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))

--1 * 2
1 - - 2 *
(* (- (- 1)) 2)

--f . g
f g . - -
(- (- (. f g)))

-9!
9 ! -
(- (! 9))

f . g !
f g . !
(! (. f g))

(((0)))
0
0

(1 + 2) * 3
1 2 + 3 *
(* (+ 1 2) 3)

1 + (2 * 3)
1 2 3 * +
(+ 1 (* 2 3))
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>We actually could have done it with the original recursive formulation as well.
Placing <code>print</code> statements at all points where we construct an <code>S</code> node prints expression in a reverse polish notation,
proving that the recursive algorithm does the same steps and in the same order as the shunting yard.</p>
</div>
<div class="paragraph">
<p>Q.E.D.</p>
</div>
<div class="paragraph">
<p>The code from this and the previous article is available here: <a href="https://github.com/matklad/minipratt" class="bare">https://github.com/matklad/minipratt</a>.</p>
</div>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2020-04-15-from-pratt-to-dijkstra.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
