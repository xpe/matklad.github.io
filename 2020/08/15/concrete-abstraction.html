<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Code Smell: Concrete Abstraction</title>
  <meta name="description"
    content="This is a hand-wavy philosophical article about programming, without quantifiable justification, but with some actionable advice and a case study.">
  <link rel="canonical" href="https://matklad.github.io//2020/08/15/concrete-abstraction.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Code Smell: Concrete Abstraction</h1>
  <div class="post-meta sect1">Aug 15, 2020</div>
  <div class="paragraph">
<p>This is a hand-wavy philosophical article about programming, without quantifiable justification, but with some actionable advice and a case study.</p>
</div>
<div class="paragraph">
<p>Suppose that there are two types in the program, <code>Blorb</code> and <code>Gonk</code>.
Suppose also that they both can <code>blag</code>.</p>
</div>
<div class="paragraph">
<p>Does it make sense to add the following trait?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">trait</span> <span class="n">Blag</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">blag</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I claim that it makes sense only if you have a function like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">blagyify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Blag</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, if some part of you program is generic over <code>T: Blag</code>.</p>
</div>
<div class="paragraph">
<p>If in every <code>x.blag()</code> the <code>x</code> is either <code>Blorg</code>, or <code>Gonk</code>, but never a <code>T</code> (each usage is <em>concrete</em>), you don&#8217;t need this abstraction.
&#8220;Need&#8221; is used in a literal sense here: replace a trait with two inherent methods named <code>blag</code>, and the code will be essentially the same.
Using a trait here doesn&#8217;t achieve any <a href="https://caseymuratori.com/blog_0015">semantic compression</a>.</p>
</div>
<div class="paragraph">
<p>Given that abstractions have costs &#8220;don&#8217;t need&#8221; can be strengthen to &#8220;probably shouldn&#8217;t&#8221;.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What Is The Cost of Abstraction?</div>
<div class="paragraph">
<p><em>First</em> is the cognitive cost&#8201;&#8212;&#8201;generics (and abstractions in general) are often harder to understand than concretions.
I think this is true regardless of the abstraction <em>skill</em>.
I am skilled with  math which is incomparably more complicated than the typical code; still, I find concrete code easier to understand.
There are exceptions here (you can do less things with <code>T: Default</code> than with <code>Blorb</code>), but they seem to be exceptions rather than a common case.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, in the context of Rust, is the compile time cost.
It is important to understand <em>why</em> it is the case.
&#8220;Traits are more complicated for compiler to understand&#8221; would be a wrong reason.
Rust uses monomorphization to compile generic code.
An <code>fn foo&lt;T&gt;</code> is compiled afresh for each different <code>T</code>, <em>per crate</em>.
If <code>foo&lt;T&gt;</code> is defined in crate <code>a</code>, and <code>foo::&lt;i32&gt;</code> is called in crates <code>b</code> and <code>c</code>, then <code>rustc</code> compiles the same code twice.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, it often is just more code to write and read.
Consider the original <code>Blag</code> example.
For non-abstract case, there are two inherent impls with <code>blag</code> function.
For abstract case there are these same two impls, plus a trait definition, <em>plus</em> a <code>use Blag</code> on every call-site.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Not going for an abstraction often allows a for more specific interface.
A monad in Haskell is a thing with <code>&gt;&gt;=</code>.
Which isn&#8217;t telling much.
Languages like Rust and OCaml can&#8217;t express a general monad, but they still have concrete monads.
The <code>&gt;&gt;=</code> is called <code>and_then</code> for futures and <code>flat_map</code> for lists.
These names are <em>more specific</em> than <code>&gt;&gt;=</code> and are easier to understand.
The <code>&gt;&gt;=</code> is only required if you want to write code generic over type of monad itself, which happens rarely.</p>
</div>
<div class="paragraph">
<p>Another example of abstraction which is used mostly concretely are collection hierarchies.
In Java or Scala, there&#8217;s a whole type hierarchy for things which can hold other things.
Rust&#8217;s type system can&#8217;t express <code>Collection</code> trait, so we have to get by with using <code>Vec</code>, <code>HashSet</code> and <code>BTreeSet</code> directly.
And it isn&#8217;t actually a problem in practice.
Turns out, writing code which is generic over collections (and not just over iterators) is not that useful.
The &#8220;but I can change the collection type later&#8221; argument also seems overrated&#8201;&#8212;&#8201;often, there&#8217;s only single collection type that makes sense.
Moreover, swapping <code>HashSet</code> for <code>BTreeSet</code> is mostly just a change at the definition site, as the two happen to have almost identical interface anyway.
The only case where I miss Java collections is when I return <code>Vec&lt;T&gt;</code>, but mean a generic <em>unordered</em> collection.
In Java, the difference is captured by <code>List&lt;T&gt;</code> vs <code>Collection&lt;T&gt;</code>.
In Rust, there&#8217;s nothing built-in for this.
It is possible to define a <code>VecSet&lt;T&gt;(Vec&lt;T&gt;)</code>, but doesn&#8217;t seem worth the effort.</p>
</div>
<div class="paragraph">
<p>Collections also suffer from <code>&gt;&gt;=</code> problem&#8201;&#8212;&#8201;collapsing similar synonyms under a single name.
Java&#8217;s
<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a>
has <code>add</code>, <code>offer</code>, <code>remove</code>, and <code>poll</code> methods, because it needs to be a collection, but also is a special kind of collection.
In C&#43;&#43;, you have to spell <code>push_back</code> for <code>vector</code>'s push operation, so that it duck-types with <code>deque</code>'s <code>front</code> and <code>back</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Collection hierarchy is a sufficient, but not necessary condition for mixing up method names.
Rust&#8217;s <code>BinaryHeap</code> should have had <code>BinaryHeap::pop_max</code> method.
Alas, we are stuck with <code>pop</code>, which, coupled with the fact that the heap is surprisingly and uselessly a max-heap, means many student-hours wasted on debugging misbehaving Dijkstra algorithm.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, the promised case study!
rust-analyzer needs to convert a bunch of internal type to types suitable for converting them into JSON message of the Language Server Protocol.
<code>ra::Completion</code> is converted into <code>lsp::Completion</code>; <code>ra::Completion</code> contains <code>ra::TextRange</code> which is converted to <code>lsp::Range</code>, etc.</p>
</div>
<div class="paragraph">
<p>The first implementation started with an abstraction for conversion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">Conv</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">conv</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This abstraction doesn&#8217;t work for all cases&#8201;&#8212;&#8201;sometimes the conversion requires additional context.
For example, to convert a rust-analyzer&#8217;s offset (a position of byte in the file) to an LSP position (<code>(line, column)</code> pair), a table with positions of newlines is needed.
This is easy to handle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">ConvWith</span><span class="o">&lt;</span><span class="n">CTX</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">conv_with</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">CTX</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Naturally, there was an intricate web of delegating impls.
The typical one looked like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">ConvWith</span><span class="o">&lt;&amp;</span><span class="n">LineIndex</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">TextRange</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">Range</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">conv_with</span><span class="p">(</span>
        <span class="k">self</span><span class="p">,</span>
        <span class="n">line_index</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">LineIndex</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">lsp_types</span><span class="p">::</span><span class="n">Range</span> <span class="p">{</span>
        <span class="nn">Range</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
            <span class="k">self</span><span class="nf">.start</span><span class="p">()</span><span class="nf">.conv_with</span><span class="p">(</span><span class="n">line_index</span><span class="p">),</span>
            <span class="k">self</span><span class="nf">.end</span><span class="p">()</span><span class="nf">.conv_with</span><span class="p">(</span><span class="n">line_index</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>There were a couple of genuinely generic impls for converting iterators of convertible things.</p>
</div>
<div class="paragraph">
<p>The code was hard to understand.
It also was hard to use: if calling <code>.conv</code> didn&#8217;t work immediately, it took a lot of time to find which specific impl didn&#8217;t apply.
Finally, there were many accidental (as in &#8220;accidental complexity&#8221;) changes to the shape of code: <code>CTX</code> being passed by value or by reference, switching between generic parameters and associated types, etc.</p>
</div>
<div class="paragraph">
<p>I was really annoyed by how this conceptually simple pure boilerplate operation got expressed as clever and fancy abstraction.
Crucially, almost all of the usages of the abstraction (besides those couple of iterator impls) were concrete.
So I replaced the whole edifice with much simpler code, a bunch of functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">range</span><span class="p">(</span>
    <span class="n">line_index</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">LineIndex</span><span class="p">,</span>
    <span class="n">range</span><span class="p">:</span> <span class="n">TextRange</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">lsp_types</span><span class="p">::</span><span class="n">Range</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nf">position</span><span class="p">(</span><span class="n">line_index</span><span class="p">,</span> <span class="n">range</span><span class="nf">.start</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nf">position</span><span class="p">(</span><span class="n">line_index</span><span class="p">,</span> <span class="n">range</span><span class="nf">.end</span><span class="p">());</span>
    <span class="nn">lsp_types</span><span class="p">::</span><span class="nn">Range</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">position</span><span class="p">(</span>
    <span class="n">line_index</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">LineIndex</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">TextSize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">lsp_types</span><span class="p">::</span><span class="n">Position</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Simplicity and ease of use went up tremendously.
Now instead of typing <code>x.conv()</code> and trying to figure out why an impl I think should apply doesn&#8217;t apply, I just auto-complete <code>to_proto::range</code> and let the compiler tell me exactly which types don&#8217;t line up.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve lost fancy iterator impls, but the
<a href="https://github.com/rust-analyzer/rust-analyzer/pull/4418/commits/1586bab0b97bef411e6187dfc389557edbc5a16e">total diff</a>
for the commit was <code>+999,-1123</code>.
There was some genuine code re-use in those impls, but it was not justified by the overall compression, even disregarding additional complexity tax.</p>
</div>
<div class="paragraph">
<p>To sum up, &#8220;is this abstraction used exclusively concretely?&#8221; is a meaningful question about the overall shape of code.
If the answer is &#8220;Yes!&#8221;, then the abstraction can be replaced by a number of equivalent non-abstract implementations.
As the latter tend to be simpler, shorter, and more direct, &#8220;Concrete Abstraction&#8221; can be considered a code smell.
As usual though, any abstract programming advice can be applied only in a concrete context&#8201;&#8212;&#8201;don&#8217;t blindly replace abstractions with concretions, check if provided justifications work for your particular case!</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/iaic5w/blog_post_code_smell_concrete_abstraction/">/r/rust</a>.</p>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2020-08-15-concrete-abstraction.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
