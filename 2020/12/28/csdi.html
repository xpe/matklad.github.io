<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Call Site Dependency Injection</title>
  <meta name="description"
    content="This post documents call site dependency injection pattern.It is a rather low level specimen and has little to do with enterprise DI.The pattern is somewhat ...">
  <link rel="canonical" href="https://matklad.github.io//2020/12/28/csdi.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Call Site Dependency Injection</h1>
  <div class="post-meta sect1">Dec 28, 2020</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This post documents call site dependency injection pattern.
It is a rather low level specimen and has little to do with enterprise DI.
The pattern is somewhat Rust-specific.</p>
</div>
<div class="paragraph">
<p>Usually, when you implement a type which needs some user-provided functionality, the first thought is to supply it in constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Engine</span> <span class="p">{</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Engine</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Engine</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">go</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we implement <code>Engine</code> and the caller supplies <code>Config</code>.</p>
</div>
<div class="paragraph">
<p>An alternative is to pass the dependency to every method call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Engine</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Engine</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Engine</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">go</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Config</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>In Rust, the latter (call-site injection) sometimes works with lifetimes better.
Let&#8217;s see the examples!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lazy-field"><a class="anchor" href="#lazy-field"></a>Lazy Field</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the first example, we want to lazily compute a field&#8217;s value based on other fields.
Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Widget</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">name_hash</span><span class="p">:</span> <span class="n">Lazy</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Widget</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Widget</span> <span class="p">{</span>
        <span class="n">Widget</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name_hash</span><span class="p">:</span> <span class="nn">Lazy</span><span class="p">::</span><span class="nf">new</span><span class="p">(||</span> <span class="p">{</span>
                <span class="nf">compute_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.name</span><span class="p">)</span>
            <span class="p">}),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem with this design is that it doesn&#8217;t work in Rust.
The closure in <code>Lazy</code> needs access to <code>self</code>, and that would create a self-referential data structure!</p>
</div>
<div class="paragraph">
<p>The solution is to supply the closure at the point where the <code>Lazy</code> is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Widget</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">name_hash</span><span class="p">:</span> <span class="n">OnceCell</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Widget</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Widget</span> <span class="p">{</span>
        <span class="n">Widget</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">name_hash</span><span class="p">:</span> <span class="nn">OnceCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">name_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.name_hash</span><span class="nf">.get_or_init</span><span class="p">(||</span> <span class="p">{</span>
            <span class="nf">compute_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.name</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="indirect-hash-table"><a class="anchor" href="#indirect-hash-table"></a>Indirect Hash Table</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next example is about plugging a custom hash function into a hash table.
In Rust&#8217;s standard library, this is only possible on the type level, by implementing the <code>Hash</code> trait for a type.
A more general design would be to parameterize the table with a hash function at run-time.
This is what C&#43;&#43; does.
However in Rust this won&#8217;t be general enough.</p>
</div>
<div class="paragraph">
<p>Consider a string interner, which stores strings in a vector and additionally maintains a hash-based index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Interner</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">set</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Interner</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>set</code> field stores the strings in a hash table, but it represents them using indices into neighboring <code>vec</code>.</p>
</div>
<div class="paragraph">
<p>Constructing the <code>set</code> with a closure wont work for the same reason <code>Lazy</code> didn&#8217;t work&#8201;&#8212;&#8201;this creates a self-referential structure.
In C&#43;&#43; there exists a work-around&#8201;&#8212;&#8201;it is possible to box the <code>vec</code> and share a stable pointer between <code>Interner</code> and the closure.
In Rust, that would create aliasing, preventing the use of <code>&amp;mut Vec</code>.</p>
</div>
<div class="paragraph">
<p>Curiously, using a sorted vec instead of a hash works with std APIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Interner</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c">// Invariant: sorted</span>
    <span class="n">set</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Interner</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">self</span><span class="py">.set</span><span class="nf">.binary_search_by</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">idx</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.cmp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="p">});</span>
        <span class="k">match</span> <span class="n">idx</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.set</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">self</span><span class="py">.vec</span><span class="nf">.len</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">s</span><span class="nf">.to_string</span><span class="p">());</span>
                <span class="k">self</span><span class="py">.set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
                <span class="n">res</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">fn</span> <span class="nf">lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is because the closure is supplied at the call site rather than at the construction site.</p>
</div>
<div class="paragraph">
<p>The hashbrown crate provides this style of API for hashes via <a href="https://docs.rs/hashbrown/0.9.1/hashbrown/hash_map/struct.HashMap.html#method.raw_entry_mut">RawEntry</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="per-container-allocators"><a class="anchor" href="#per-container-allocators"></a>Per Container Allocators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The third example is from the Zig programming language.
Unlike Rust, Zig doesn&#8217;t have a blessed global allocator.
Instead, containers in Zig come in two flavors.
The &#8220;Managed&#8221; flavor accepts an allocator as a constructor parameter and stores it as a field
(<a href="https://github.com/ziglang/zig/blob/1590ed9d6aea95e5a21e3455e8edba4cdb374f2c/lib/std/array_list.zig#L36-L43">Source</a>).
The &#8220;Unmanaged&#8221; flavor adds an <code>allocator</code> parameter to every method
(<a href="https://github.com/ziglang/zig/blob/1590ed9d6aea95e5a21e3455e8edba4cdb374f2c/lib/std/array_list.zig#L436-L440">Source</a>).</p>
</div>
<div class="paragraph">
<p>The second approach is more frugal&#8201;&#8212;&#8201;it is possible to use a single allocator reference with many containers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fat-pointers"><a class="anchor" href="#fat-pointers"></a>Fat Pointers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The final example comes from the Rust language itself.
To implement dynamic dispatch, Rust uses fat pointers, which are two words wide.
The first word points to the object, the second one to the vtable.
These pointers are manufactured at the point where a concrete type is used generically.</p>
</div>
<div class="paragraph">
<p>This is different from C&#43;&#43;, where vtable pointer is embedded into the object itself during construction.</p>
</div>
<hr>
<div class="paragraph">
<p>Having seen all these examples, I am warming up to Scala-style implicit parameters.
Consider this hypothetical bit of Rust code with Zig-style vectors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">get_allocator</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">xs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ys</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">xs</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ys</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem here is <code>Drop</code>&#8201;&#8212;&#8201;freeing the vectors requires access to the allocator, and it&#8217;s unclear how to provide one.
Zig dodges the problem by using defer statement rather than destructors.
In Rust with implicit parameters, I imagine the following would work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">implicit</span> <span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Allocator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Drop</span> <span class="k">for</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<hr>
<div class="paragraph">
<p>To conclude, I want to share one last example where CSDI thinking helped me to discover a better application-level architecture.</p>
</div>
<div class="paragraph">
<p>A lot of rust-analyzer&#8217;s behavior is configurable.
There are toggles for inlay hints, completion can be tweaked, and some features work differently depending on the editor.
The first implementation was to store a global <code>Config</code> struct together with the rest of analysis state.
Various subsystems then read bits of this <code>Config</code>.
To avoid coupling distinct features together via this shared struct, config keys were dynamic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="k">type</span> <span class="n">Config</span> <span class="o">=</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This system worked, but felt rather awkward.</p>
</div>
<div class="paragraph">
<p>The current implementation is much simpler.
Rather than storing a single <code>Config</code> as a part of the state, each method now accepts a specific config parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">get_completions</span><span class="p">(</span>
    <span class="n">analysis</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Analysis</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">CompletionConfig</span><span class="p">,</span>
    <span class="n">file</span><span class="p">:</span> <span class="n">FileId</span><span class="p">,</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">fn</span> <span class="nf">get_inlay_hints</span><span class="p">(</span>
    <span class="n">analysis</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Analysis</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HintsConfig</span><span class="p">,</span>
    <span class="n">file</span><span class="p">:</span> <span class="n">FileId</span><span class="p">,</span>
<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Not only the code is simpler, it is more flexible.
Because configuration is no longer a part of the state, it is possible to use different configs for the same functionality depending on the context.
For example, explicitly invoked completion might be different from the asynchronous one.</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://old.reddit.com/r/rust/comments/kmd41e/blog_post_call_site_dependency_injection/">/r/rust</a>.</p>
</div>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2020-12-28-csdi.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
