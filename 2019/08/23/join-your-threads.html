<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Join Your Threads</title>
  <meta name="description"
    content="This is a note on how to make multithreaded programs more robust.It&#8217;s not really specific to Rust, but I get to advertise my new jod-thread micro-crate :)">
  <link rel="canonical" href="https://matklad.github.io//2019/08/23/join-your-threads.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io//feed.xml">

  <style>
    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
    }

    @font-face {
      font-family: 'JetBrains Mono';
      src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
      ;
      font-weight: bold;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      margin-block-start: 0;
      margin-block-end: 0;
    }

    h1,
    h2,
    h3 {
      font-weight: 300;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    main {
      display: flex;
      flex-direction: column;
      width: 100%;
      max-width: 80ch;
      padding-left: 2ch;
      padding-right: 2ch;
    }

    .site-header {
      width: 100%;
      max-width: 80ch;
      margin-bottom: 1.5rem;
    }

    .site-header>nav {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
    }

    .site-header .-title {
      flex-grow: 2;
    }

    .site-footer {
      display: flex;
      justify-content: center;
      align-items: baseline;
      width: 100%;
      max-width: 80ch;
      margin-top: 1rem;
      height: 2rem;
      padding-left: 1ch;
      padding-right: 1ch;
    }
  </style>
  <link rel="stylesheet" href=" /css/adoc.css">
  <link rel="stylesheet" href=" /css/rouge-github.css">
  <link rel="stylesheet" href=" /css/main.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header class="site-header">
    <nav>
      <a class="-title" href="/">matklad</a>
      
      
      <a href="/about/">About</a>
      
      
      
      
      
      <a href="/resume/">Resume</a>
      
      
      
      
      
      
      
      
      
      
    </nav>
  </header>

  <main>
    <article>
  <h1>Join Your Threads</h1>
  <div class="post-meta sect1">Aug 23, 2019</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is a note on how to make multithreaded programs more robust.
It&#8217;s not really specific to Rust, but I get to advertise my new <a href="https://crates.io/crates/jod-thread">jod-thread</a> micro-crate :)</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you&#8217;ve created a fresh new thread with <code>std::thread::spawn</code>, but haven&#8217;t call <code>JoinHandle::join</code> anywhere in your program.
What can go wrong in this situation?
As a reminder, <code>join</code> blocks until the thread represented by handle completes successfully or with a panic.</p>
</div>
<div class="paragraph">
<p><em>First</em>, if the <code>main</code> function finishes earlier, some destructors on that other thread&#8217;s stack might not run.
It&#8217;s not a big deal if all that destructors do is just freeing memory: the OS cleanups after the process exit anyway.
However, <code>Drop</code> could have been used for something like flushing IO buffers, and that is more problematic.</p>
</div>
<div class="paragraph">
<p><em>Second</em>, not joining threads can lead to surprising interference between unrelated parts of the program and in general to more chaotic behavior.
Imagine, for example, running a test suite with many tests.
In this situation typical "singleton" threads may accumulate during a test run.
Another scenario is spawning helper threads when processing tasks.
If you don&#8217;t join these threads, you might end up using more resources than there are concurrent tasks, making it harder to measure the load.
To be clear, if you <em>don&#8217;t</em> call <code>join</code>, the thread will complete at some point anyway, it won&#8217;t leak or anything.
But this <em>some</em> point is non-deterministic.</p>
</div>
<div class="paragraph">
<p><em>Third</em>, If a thread panics in a forest, and no one is around to hear it, does it make a sound?
The <code>join</code> method returns a <code>Result</code>, which is be an <code>Err</code> if the thread has panicked.
If you don&#8217;t join the thread, you won&#8217;t get a chance to react to this event.
So, unless you are looking at the <code>stderr</code> at this moment, you might not realize that something is wrong!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you haven&#8217;t read the <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on Structured Concurrency</a>, do it now!
It&#8217;s a much longer post than mine, but is also more general.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It seems like joining the threads by default is a good idea.
However, <em>just</em> calling <code>JoinHandle::join</code> is not enough:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">thread</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="p">{</span>
    <span class="cm">/* useful work */</span>
<span class="p">});</span>

<span class="c">// ...</span>

<span class="n">thread</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span> <span class="c">// propagate the panic</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is, code in <code>...</code> might use <code>?</code> (or some other form of early return), or it can panic, and in both cases the thread won&#8217;t be joined.
As usual, the solution is to put the &#8220;cleanup&#8221; operation into a <code>Drop</code> impl.
That&#8217;s exactly what my crate, <a href="https://crates.io/crates/jod-thread"><code>jod_thread</code></a>, does!
Note that this is really a micro crate, so consider just rolling your own <strong>j</strong>oin <strong>o</strong>n <strong>d</strong>rop.
The value is not in the code, it&#8217;s in the pattern of never leaving a loose thread behind!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-look-at-c"><a class="anchor" href="#a-look-at-c"></a>A Look At C&#43;&#43;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As usual, it is instructive to contrast and compare Rust and C&#43;&#43;.</p>
</div>
<div class="paragraph">
<p>In C&#43;&#43;, <code>std::thread</code> has this interesting peculiarity that it terminates the process in destructor unless you call <code>.join</code> (which works just like in Rust) or <code>.detach</code> (which says &#8220;I won&#8217;t be joining this thread at all&#8221;).
In other words, C&#43;&#43; mandates that you explicitly choose between joining and detaching.
Why is that?</p>
</div>
<div class="paragraph">
<p>It&#8217;s easy to argue that detach by default is a wrong choice for C&#43;&#43;: it can easily lead to undefined behavior if the lambda passed to the thread uses values from parent&#8217;s stack frame.</p>
</div>
<div class="paragraph">
<p>Or, as Scott Meyer poetically puts it in the Item 37 of <a href="https://www.aristeia.com/EMC++.html">Effective Modern C&#43;&#43;</a> (which is probably the best book to read if you are into both Rust and C&#43;&#43;):</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In <code>doWork</code>, for example, <code>goodVals</code> is a local variable that is captured by reference.
It’s also modified inside the lambda (via the call to <code>push_back</code>).
Suppose, then, that while the lambda is running asynchronously, <code>conditionsAreSatisfied()</code> returns <code>false</code>.
In that case, <code>doWork</code> would return, and its local variables (including <code>goodVals</code>) would be destroyed.
Its stack frame would be popped, and execution of its thread would continue at <code>doWork</code>’s call site.</p>
</div>
<div class="paragraph">
<p>Statements following that call site would, at some point, make additional function calls, and at least one such call would probably end up using some or all of the memory that had once been occupied by the doWork stack frame.
Let’s call such a function <code>f</code>.
While <code>f</code> was running, the lambda that doWork initiated would still be running asynchronously.
That lambda could call push_back on the stack memory that used to be <code>goodVals</code> but that is now somewhere inside <code>f</code>’s stack frame.
Such a call would modify the memory that used to be <code>goodVals</code>, and that means that from <code>f</code>’s perspective, the content of memory in its stack frame could spontaneously change!
Imagine the fun you’d have debugging <em>that</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This also happens to be one of my favorite arguments for &#8220;why Rust?&#8221; :)</p>
</div>
<div class="paragraph">
<p>The reasoning behind not making <code>join</code> the default is less clear cut.
The book says that <code>join</code> by default is be counterintuitive, but that is somewhat circular: it is surprising precisely because it is not the default.</p>
</div>
<div class="paragraph">
<p>In Rust, unlike C&#43;&#43;, implicit detach can&#8217;t cause undefined behavior (compiler will just refuse the code if the lambda borrows from the stack).
I suspect this "we can, so why not?" is the reason why Rust detaches by default.</p>
</div>
<div class="paragraph">
<p>However, there&#8217;s a twist!
C&#43;&#43; core guidelines now recommend to always use <code>gsl::joining_thread</code> (which does implicit join) over <code>std::thread</code> in  <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp25-prefer-gsljoining_thread-over-stdthread">CP.25</a>.
The following <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp26-dont-detach-a-thread">CP.26</a> reinforces the point by advising against <code>.detach()</code> method.
The reasoning is roughly similar to my post: detached threads make the program more chaotic, as they add superfluous degrees of freedom to the runtime behavior.</p>
</div>
<div class="paragraph">
<p>It&#8217;s interesting that I&#8217;ve learned about these two particular guidelines only today, when refreshing my C&#43;&#43; for this section of the post!</p>
</div>
<div class="paragraph">
<p>So, it seems like both C&#43;&#43; and Rust picked the wrong default for the thread API in this case. But at least C&#43;&#43; has official guidelines recommending the better approach.
And Rust, &#8230;&#8203; well, Rust has  my blog post now :-)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-silver-bullet"><a class="anchor" href="#a-silver-bullet"></a>A Silver Bullet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Of course there isn&#8217;t one!
Joining on drop seems to be a better default, but it brings its own problems.
The nastiest one is deadlocks: if you are joining a thread which waits for something else, you might wait forever.
I don&#8217;t think there&#8217;s an easy solution here: <em>not</em> joining the thread lets you forget about the deadlock, and may even make it go away (if a child thread is blocked on the parent thread), but you&#8217;ll get a detached thread on your hands!
The fix is to just arrange the threads in such a way that shutdown is always orderly and clean.
Ideally, shutdown should work the same for both the happy and panicking path.</p>
</div>
<div class="paragraph">
<p>I want to discuss a specific instructive issue that I&#8217;ve solved in <a href="https://github.com/rust-analyzer/rust-analyzer">rust-analyzer</a>.
It was about the usual setup with a worker thread that consumes items from a channel, roughly like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">frobnicate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nf">channel</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">worker</span> <span class="o">=</span> <span class="nn">jod_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="n">receiver</span> <span class="p">{</span>
            <span class="nf">do_work</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="c">// prepare some work and send it via sender</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the worker thread has a simple termination condition: it stops when the channel is closed.
However, here lies the problem: we create the channel before the thread, so the <code>sender</code> is dropped <em>after</em> the <code>worker</code>.
This is a deadlock: <code>frobnicate</code> waits for <code>worker</code> to exit, and <code>worker</code> waits for <code>frobnicate</code> to drop the <code>sender</code>!</p>
</div>
<div class="paragraph">
<p>There&#8217;s a straightforward fix: drop the <code>sender</code> first!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">frobnicate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nf">channel</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">worker</span> <span class="o">=</span> <span class="nn">jod_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="n">receiver</span> <span class="p">{</span>
            <span class="nf">do_work</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="c">// prepare some work and send it via sender</span>

    <span class="k">drop</span><span class="p">(</span><span class="n">sender</span><span class="p">);</span>
    <span class="k">drop</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>This solution, while obvious, has a pretty serious problem!
The <code>prepare some work ...</code> bit of code can contain early returns due to error handling or it may panic.
In both case the result is a deadlock.
What is the worst, now deadlock happens only on the <em>unhappy</em> path!</p>
</div>
<div class="paragraph">
<p>There is an elegant, but tricky fix for this. Take a minute to think about it!
How to change the above snippet such that the <code>worker</code> thread is guranted to be joined, without deadlocks, regardless of the exit condition (normal termination,<code>?</code>, panic) of <code>frobnicate</code>?</p>
</div>
<div class="paragraph">
<p>The answer will be below these beautiful Ukiyo-e prints :-)</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Red_Fuji_southern_wind_clear_morning.jpg/1024px-Red_Fuji_southern_wind_clear_morning.jpg" alt="1024px Red Fuji southern wind clear morning">
</div>
<div class="title">Fine Wind, Clear Morning</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Lightnings_below_the_summit.jpg/1024px-Lightnings_below_the_summit.jpg" alt="1024px Lightnings below the summit">
</div>
<div class="title">Rainstorm Beneath the Summit</div>
</div>
<div class="paragraph">
<p>First of all, the problem we are seeing here is an instance of a very general setup.
We have a bug which only manifests itself if a rare error condition arises.
In some sense, we have a bug in the (implicit) error handling (just like <a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/yuan">92%</a> of critical bugs).
The solutions here are a classic:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Artificially trigger unhappy path often ("restoring from backup every night").</p>
</li>
<li>
<p>Make sure that there aren&#8217;t different happy and unhappy paths ("crash only software").</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We are going to do the second one.
Specifically, we&#8217;ll arrange the code in such way that compiler automatically drops <code>worker</code> first, without the need for explicit <code>drop</code>.</p>
</div>
<div class="paragraph">
<p>Something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">worker</span> <span class="o">=</span> <span class="nn">jod_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span> <span class="o">...</span> <span class="p">});</span>
<span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nf">channel</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem here is that we need <code>receiver</code> inside the worker, but moving <code>let (sender, receiver)</code> up brings us back to the square one.
Instead, we do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">worker</span><span class="p">;</span>
<span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nf">channel</span><span class="p">();</span>
<span class="n">worker</span> <span class="o">=</span> <span class="nn">jod_thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span> <span class="o">...</span> <span class="p">});</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Beautiful, isn&#8217;t it?
And super cryptic: the <a href="https://github.com/rust-analyzer/ra_vfs/blob/af1a6ace3d0edf57d62a76321e3e52eeb99d6d4c/src/io.rs#L71-L83">real code</a> has a sizable comment chunk!</p>
</div>
<div class="paragraph">
<p>The second big issue with join by default is that, if you have many threads in the same scope, and one of them errors, you really want to not only <em>wait</em> until others are finished, but to actually cancel them.
Unfortunately, cancelling a thread is a notoriously thorny problem, which I&#8217;ve explained a bit in <a href="/2018/07/24/exceptions-in-structured-concurrency.html">another post</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="wrapping-up"><a class="anchor" href="#wrapping-up"></a>Wrapping Up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So, yeah, join your threads, but be on guard about deadlocks!
Note that most of the time one shouldn&#8217;t actually spawn threads manually: instead, tasks should be spawned to a common threadpool.
This way, physical parallelism is nicely separated from logical concurrency.
However, tasks should generally be joined for the same reason threads should be joined.
A nice additional properly of tasks is that joining the threadpool itself in the end ensures that no tasks are leaked in the single place.</p>
</div>
<div class="paragraph">
<p>A part of the inspiration for this post was the fact that I once forgot to join a thread :(
This rather embarrassingly happened in my <a href="/2018/03/03/stopping-a-rust-worker.html">other post</a>.
Luckily, my current colleague <a href="https://github.com/stjepang">Stjepan Glavina</a> <a href="https://github.com/rust-lang/rust/issues/48820">noticed this</a>.
Thank you, Stjepan!</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/cummsx/blog_post_join_your_threads/">r/rust</a>.</p>
</div>
</div>
</div>
</article>

  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/_posts/2019-08-23-join-your-threads.adoc">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href=" /feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
